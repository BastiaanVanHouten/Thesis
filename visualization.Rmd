---
title: "Visualization"
author: "Bastiaan"
date: "2023-09-20"
output: html_document
---

```{r echo=FALSE }
# load packages
library(interactions)
library(readr)
library(dplyr)
library(broom)
library(ggplot2)
library(ggpubr)
library(car)
library(MASS)


df <- read_csv("~/Master/Thesis/gen/data-preparation/output/thanos_endgame.csv", 
                           col_types = cols(imdb.com_releasedate = col_datetime(format = "%Y-%d-%m")))
```

# Let's start by removing the outliers. 
```{r echo=FALSE}
# Create a scatterplot
ggplot(df, aes(x = imdb.com_imdbid, y = Avg_Rank_Third_Year)) +
  geom_point() +
  labs(
    x = "Movie Index",  # Label for x-axis
    y = "Avg Rank Third Year",
    title = "Scatterplot of Avg Rank Third Year vs. Movie Index"
  )

# Calculate the IQR
q1 <- quantile(df$Avg_Rank_Third_Year, 0.25, na.rm = TRUE)
q3 <- quantile(df$Avg_Rank_Third_Year, 0.75, na.rm = TRUE)
iqr <- q3 - q1

# Define the lower and upper bounds for outliers
lower_bound <- q1 - 1.5 * iqr
upper_bound <- q3 + 1.5 * iqr

# Remove outliers from the dataset
df_clean <- df[df$Avg_Rank_Third_Year >= lower_bound & df$Avg_Rank_Third_Year <= upper_bound, ]

# Create a new boxplot without outliers
ggplot(df_clean, aes(y = Avg_Rank_Third_Year)) +
  geom_boxplot() +
  labs(
    y = "Avg Rank Third Year (Outliers Removed)",
    title = "Boxplot of Avg Rank Third Year (Outliers Removed)"
  )


# Create a scatterplot
ggplot(df_clean, aes(x = imdb.com_imdbid, y = Avg_Rank_Third_Year)) +
  geom_point() +
  labs(
    x = "Movie Index",  # Label for x-axis
    y = "Avg Rank Third Year",
    title = "Scatterplot of Avg Rank Third Year vs. Movie Index"
  )
```

# Let's see if box office is related to average ranking 

```{ r echo=FALSE}

df_clean$Box.Office <- as.numeric(df_clean$Box.Office)

model_box_office <- lm(Avg_Rank_Third_Year ~ Box.Office, data = df_clean)
model_box_office_year_1 <- lm(Avg_Rank_First_Year ~ Box.Office, data = df_clean)
model_rank_release <- lm(rank_release ~ Box.Office, data = df_clean)

# print model 
summary(model_box_office)
summary(model_box_office_year_1)
summary(model_rank_release)

# Scatterplot for model_box_office
ggplot(df, aes(x = Box.Office, y = Avg_Rank_Third_Year)) +
  geom_point() +                # Add points
  geom_smooth(method = "lm") +  # Add a linear regression line
  labs(
    x = "Box Office",
    y = "Avg Rank Third Year",
    title = "Scatterplot of Avg Rank Third Year vs. Box Office"
  )

```

# Let's first check the average ranking per year of the movies
```{R echo = FALSE}
ggplot(df_clean, aes(x = imdb.com_year, y = Avg_Rank_Third_Year)) +
  geom_line(stat = "summary", fun = "mean", fill = "skyblue") +
  labs(title = "Average Avg_Rank_Third_Year.y by imdb.com_year",
       x = "imdb.com_year",
       y = "Average Avg_Rank_Third_Year.y") +
  theme_minimal()

```

<sub> only possible explanation that top 250 or etc. is a very difficult to get to. The movies that have been published the more competitive it is to have a movie that keeps remaining popular.Therefore, it is logical that the movies that are newer are less popular after three years. Nevertheless, it is very difficult to explain why these movies popularity dropped so much after 2011.  
# We noticed that the rankings for the movies before 2000 were not that accurate 
```{r echo=FALSE}
df_clean <- df_clean %>%
  filter(imdb.com_year > 2000)
```
# This would be the regression of the main analysis
<sub> to achieve homoskedacity we did filter out the movies that were before 2000. But we did not filter out outliners.  

```{r echo = FALSE}
df_clean <- df
df_clean <- na.omit(df_clean)

small_constant <- 0.001  # You can change this value if needed

df_clean$log_Nominee <- log(df_clean$Nominee + small_constant)
df_clean$log_Winner <- log(df_clean$Winner + small_constant)
df_clean$log_remake <- log(df_clean$imdb.com_remake + small_constant)
df_clean$log_simpson_index <- log(df_clean$simpson_index + small_constant)
df_clean$log_op_theater <- log(df_clean$boxofficemojo.com_openingtheaters + small_constant)

# Create the main regression model
model <- lm(log(Avg_Rank_Third_Year) ~ simpson_index+ 
                boxofficemojo.com_openingtheaters + 
                log(imdb.com_runtime) + mpaa_numeric + 
                log(average_budget) + 
                imdb.com_year +
                imdb.com_sequel + 
                imdb.com_spinoff +
                log_remake +
                imdb.com_basedonbook + 
                imdb.com_basedonbookseries + 
                imdb.com_basedonplay + 
                imdb.com_basedoncomic + 
                imdb.com_basedoncomicbook + 
                imdb.com_basedonnovel + 
                imdb.com_basedonshortstory + 
                log_Nominee +
                log_Winner +
                Total_Star_Power+
                Action + Adventure + Comedy + Fantasy + Crime + Drama + Mystery + Thriller +
                Romance + Sci.Fi + Biography + Sport + War + Family + Musical + History +
                Horror + Music + Documentary + Western, # Include all genre variables
            data = df_clean)

# Select only numeric columns from your dataset
numeric_df <- df_clean[, sapply(df_clean, is.numeric)]

# Calculate the correlation matrix for numeric variables
cor_matrix <- cor(numeric_df)

# Print the correlation matrix
print(cor_matrix)



# print model 
summary(model)




```

```{r echo=FALSE}
residualPlots(model)

```
## Result from the regression model : 
<sub> In this case, the data represents a cross-sectional view of movie rankings and popularity at different points in time, with each observation corresponding to a specific year (e.g., 2001 for movies released in 1998 and 2007 for movies released in 2004).

<sub> While the data does have a time dimension in the sense that it captures movie rankings at different years after their release, it is still considered cross-sectional in nature because each observation corresponds to a single year, and you are examining movies' attributes and performance at a specific moment in time. Cross-sectional data can include information from various time points, but it does not involve tracking individual entities or observations over time. Instead, it provides a snapshot or cross-section of the data at each time point.

<sub> So, it is appropriate to refer to this data as cross-sectional data with a temporal component, where each observation corresponds to a specific year after a movie's release.

<sub> Therefore, a 0.47 for R-squared is fine and we would perfer to use a model with an interecpt eventhough the R squared for the other is higher

# Checking assumptions starting with indepence of observations
```{r echo=FALSE}

# Create residuals vs. fitted values plot
plot(model$fitted.values, model$residuals, 
     xlab = "Fitted Values", ylab = "Residuals",
     main = "Residuals vs. Fitted Values Plot")

# Create residuals vs. order plot
plot(seq_along(model$residuals), model$residuals, 
     xlab = "Observation Order", ylab = "Residuals",
     main = "Residuals vs. Order Plot")

plot(model, which = 1)  # Plots residuals vs. fitted values
plot(model, which = 3)


```

# issue of hetreskedacity
```{r echo=FALSE}
par(mfrow=c(2, 2)) # Set up a grid of plots
for (predictor in colnames(df_clean)) {
  if (predictor != "Avg_Rank_Third_Year") { # Exclude the dependent variable
    plot(df_clean[[predictor]], residuals(model),
         xlab = predictor, ylab = "Residuals",
         main = paste("Residuals vs.", predictor))
  }
}

```

```{r = echo=FALSE}
plot(model, which = 2)  # Residuals vs. Each Predictor


bp_test <- ncvTest(model)
print(bp_test)
```
# As you can see we have issues with homoskedacity and independence so we took the lof for the dv 

```{r = echo=FALSE}
# Fit your log-transformed linear regression model
model_log <- lm(log(Avg_Rank_Third_Year) ~ simpson_index + 
                boxofficemojo.com_openingtheaters + 
                imdb.com_runtime + mpaa_numeric + 
                average_budget + 
                imdb.com_year +
                imdb.com_sequel + 
                imdb.com_spinoff +
                imdb.com_remake +
                imdb.com_basedonbook + 
                imdb.com_basedonbookseries + 
                imdb.com_basedonplay + 
                imdb.com_basedoncomic + 
                imdb.com_basedoncomicbook + 
                imdb.com_basedonnovel + 
                imdb.com_basedonshortstory + 
                Nominee +
                Winner +
                Total_Star_Power+
                Action + Adventure + Comedy + Fantasy + Crime + Drama + Mystery + Thriller +
                Romance + Sci.Fi + Biography + Sport + War + Family + Musical + History +
                Horror + Music + Documentary + Western, # Include all genre variables
            data = df_clean)

# Obtain a summary of the model
model_summary <- summary(model_log )

# Extract p-values from the summary
p_values <- model_summary$coefficients[, "Pr(>|t|)"]

print(p_values)

plot(model_log, which = 2)  # Residuals vs. Each Predictor


```
# taking the square root
```{r echo=FALSE}
df_clean$sqrt_Avg_Rank_Third_Year <- sqrt(df_clean$Avg_Rank_Third_Year)

model_sqrt <- lm(sqrt_Avg_Rank_Third_Year ~ simpson_index + 
           boxofficemojo.com_openingtheaters + 
           imdb.com_runtime + mpaa_numeric + 
           average_budget + 
           imdb.com_year +
           imdb.com_sequel + 
           imdb.com_spinoff +
           imdb.com_remake +
           imdb.com_basedonbook + 
           imdb.com_basedonbookseries + 
           imdb.com_basedonplay + 
           imdb.com_basedoncomic + 
           imdb.com_basedoncomicbook + 
           imdb.com_basedonnovel + 
           imdb.com_basedonshortstory + 
           Nominee +
           Winner +
           the_numbers_com_dirpower_rank +
           Total_Star_Power+
           Action + Adventure + Comedy + Fantasy + Crime + Drama + Mystery + Thriller +
           Romance + Sci.Fi + Biography + Sport + War + Family + Musical + History +
           Horror + Music + Documentary + Western,
           data = df_clean)

print(model_sqrt)
```

# Checking assumptions starting with indepence
```{r echo=FALSE}
plot(model_log, which = 1)  # Plots residuals vs. fitted values

acf(residuals(model))  # Plots autocorrelation of residuals

```

# Checking for robustness starting with multicollinearity 

```{r}

# Calculate VIF for your linear regression model
vif_values <- vif(model)

# Print the VIF values
print(vif_values)

```

<sub> All values are below 10 so no issue

# See if some covariates influence the DV

```{r echo = FALSE}
# Create the main regression model
model_covariates_check <- lm(simpson_index ~ 
                boxofficemojo.com_openingtheaters + 
                imdb.com_runtime + mpaa_numeric + 
                average_budget + 
                imdb.com_year +
                imdb.com_sequel + 
                imdb.com_spinoff +
                imdb.com_remake +
                imdb.com_basedonbook + 
                imdb.com_basedonbookseries + 
                imdb.com_basedonplay + 
                imdb.com_basedoncomic + 
                imdb.com_basedoncomicbook + 
                imdb.com_basedonnovel + 
                imdb.com_basedonshortstory + 
                Nominee +
                Winner +
                the_numbers_com_dirpower_rank +
                Total_Star_Power+
                Action + Adventure + Comedy + Fantasy + Crime + Drama + Mystery + Thriller +
                Romance + Sci.Fi + Biography + Sport + War + Family + Musical + History +
                Horror + Music + Documentary + Western, # Include all genre variables
            data = df)



# print model 
summary(model_covariates_check)
```

<sub> imdb.com_year + , spinoff + ,basedonnovel - , genre action + , genre crime + , genre Mystery - , genre Romance -  , genre Sci Fi + ,  genre musical -, genre history - , genre Horror -, genre Music + . 

```{r echo = FALSE}
# Filter the data for movies with Music = 1
music_movies <- df[df$Music == 1, ]

# Display the filtered movies
head(music_movies$imdb.com_title, n =4)
```

<sub> music movies are movies such a dirty dancing , all eyez on me, bohemian rapsody


# Counting the movies with less than 2 for a ehtnicity

```{r echo = FALSE}

# Count the number of movies for each individual criterion (ignoring missing values)
count_asian <- sum(df$Total_Assigned_Asian < 2, na.rm = TRUE)
count_black <- sum(df$Total_Assigned_Black < 2, na.rm = TRUE)
count_hispanic <- sum(df$Total_Assigned_Hispanic < 2, na.rm = TRUE)
count_white <- sum(df$Total_Assigned_White < 2, na.rm = TRUE)

count_minorities <- sum(df$Total_Assigned_Asian < 2 & 
                        df$Total_Assigned_Black < 2 &
                        df$Total_Assigned_Hispanic < 2, na.rm = TRUE)

# Display the counts for each criterion
cat("Number of movies with Total_Assigned_Asian < 2:", count_asian, "\n")
cat("Number of movies with Total_Assigned_Black < 2:", count_black, "\n")
cat("Number of movies with Total_Assigned_Hispanic < 2:", count_hispanic, "\n")
cat("Number of movies with Total_Assigned_White < 2:", count_white, "\n")
cat("Number of movies with Total_Assigned_Minorities < 2:", count_minorities, "\n")
```

<sub> There are at least 1079 (Asian), 659 (Black), 1048 (Hispanic), white (21) movies that can not get AIR for all ethnicities. Escpeially looking at ASian and Hispanic about halve of the movies does not have AIR only looking at the actors hired not even the content of the movie.299 have less than 2 for all minority groups 

# Year is so important so let's see how diversity has developed over the years 
```{r echo = FALSE}
ggplot(df, aes(x = imdb.com_year, y = simpson_index)) +
  geom_line(stat = "summary", fun = "mean", fill = "skyblue") +
  labs(title = "Average diversity idex by imdb.com_year",
       x = "imdb.com_year",
       y = "Average Diversity") +
  theme_minimal()

```

<While the acion genre is positivly correlated to the popularity of a movie because it's intercept is negative in the first model. Nevertheless, it is positivly correlated with the diversity of a movie. While the diversity of a movie is negativly correlated with the popularity of a movie. 
```{r }
# Calculate the average of df$simpson_index
average_simpson_index <- mean(df$simpson_index, na.rm = TRUE)

# Print the average
cat("Average of Simpson Index:", average_simpson_index, "\n")
```

<sub> the average of the simpson diversity index is 0.3627456

```{r }
movie_ranks <- read_csv("gen/data-preparation/output/movie_ranks.csv")
```
